# web实时监控分析预警系统

随着我国城市化进程的快速推进，公共安全治理面临案件类型复杂化、基层警力资源紧张与安防数据利用率不足的多重挑战。据统计，2022年全国公安机关受理治安案件数突破千万量级，而基层警务人员年均增长率仅为1.2%，传统依赖人力筛查的办案模式已难以应对海量视频数据的处理需求。尽管“雪亮工程”推动城市安防摄像头覆盖率超过90%，日均产生数十PB的监控数据，但在实际应用中，视频资源的智能化挖掘仍存在显著短板：一方面，当案件仅具备模糊特征（如自然语言描述的嫌疑人形象）时，民警仍需耗费数百小时人工排查跨时空视频片段，效率低下且易遗漏关键线索；另一方面，现有系统对人脸、人体特征明确的案件虽能借助AI技术快速定位，却无法实现多模态线索的融合分析，导致视频数据的实战价值未充分释放。

针对这一困境，本团队聚焦“视频数据智能化深度应用”的核心需求，研发新一代城市态势感知系统。系统突破性地融合多模态AI技术，构建自然语言描述至视觉特征的跨模态检索能力，支持“穿深色外套、佩戴黑色背包”等200余项细粒度语义特征的复合查询，使缺乏人脸信息的案件可通过语言线索精准锁定目标，较传统人工筛查效率提升17倍。同时，系统集成先进的跨摄像头追踪算法与行为分析模型，不仅能重构目标人物的时空轨迹，还可实时解析重点区域的人员行为模式，对聚集、徘徊等异常态势实现0.8秒级预警响应。经公安部门试点验证，该系统将单警日均案件处理量从3.2件提升至9.7件，并创新性地将deepseekvl视觉理解框架与YOLOv8检测技术结合，形成国内首个支持自然语言交互的智能安防平台，为破解基层警力瓶颈、提升城市安全治理效能提供了关键技术支撑。

本项目的技术突破不仅限于公共安全领域，其多模态分析架构可延伸至交通管理、应急指挥等智慧城市应用场景。通过将人工智能的“感知力”转化为城市治理的“决策力”，系统为构建全域感知、实时响应的城市安全生态提供了创新范式，具有显著的社会效益与行业推广价值。

## 项目功能

### 1. 检测

检测人物

### 2. 预警



### 3. 查询

人脸识别，人体识别

## 项目模块

摄像头/采集设备 → Nginx-RTMP live应用 → 分析进程 → AI服务器 → Nginx-RTMP processed应用 → 前端


### 1. 摄像头 RTMP 推流
流程:

摄像头或采集设备捕获视频画面
通过编码器将原始视频压缩为 H.264 等格式
使用 RTMP 协议将编码后的视频推送
实现方式:

支持 RTMP 的摄像头设备直接推流
使用 OBS、FFmpeg 等工具从普通摄像头采集并推流
推流地址示例: rtmp://server-ip:1935/live/camera1

### 2. Nginx-RTMP 流媒体服务器接收 live
功能:

接收并暂存来自多个摄像头的 RTMP 推流
提供流的基本管理和分发能力
触发流状态回调通知 Web API
关键配置:

配置 myapp 应用接收原始推流
设置流事件回调，如 on_publish 和 on_publish_done
on_publish : 通知web_ui有新的摄像头接入




### 3. AI 服务器处理 （算法模块）

fastapi提供功能

功能:

接收来自流处理程序的视频帧
执行目标检测、人脸识别等 AI 算法
返回分析结果（如目标坐标、类别、置信度）

处理模式:

接受图片，视频，返回json


### 4. 推送到 Nginx-RTMP流媒体服务器 processed 应用
流程:

流处理程序将处理后的视频重新编码
通过 RTMP 协议推送到 Nginx 的 processed 应用
Nginx 接收并分发处理后的流
配置要点:

配置单独的 processed 应用接收处理后流
优化推流参数减少延迟
配置多协议支持(RTMP/HLS/DASH)满足不同客户端需求

### 5. Web 后端

提供后台操作页面

内部服务端交互:

用户登录管理
Web API 接收流处理状态通知
记录每个摄像头对应的原始流和处理后流地址
向客户端提供访问处理后流的地址和凭证
向ai服务器请求处理视频帧
数据库存储ai服务器返回的数据


### 6. 前端交互:

客户端通过 API 获取可用的摄像头列表
API 返回每个摄像头的处理后流地址
客户端使用适当的播放器访问流媒体地址


### 7. 分析模块

处理视频流并且调用算法。 
fastapi提供api用于控制流处理程序。
- 接受流地址
- 推流地址
- 使用算法


流程：

- 从流媒体live应用拉流，（拉流地址）
- 调用ai服务器算法处理分析，（选择算法）
- 推流到processed流媒体  （推流地址  ）

实现拉流，解码，实时分析，编码，推流功能

### 延迟与性能考量
AI 处理密度会影响整体延迟和 CPU/GPU 使用率
处理集群可用于高并发场景
通过这种分层架构，系统能够灵活扩展并处理多路视频流，同时保持合理的实时性和资源使用效率。




## 模块交互


### 交互逻辑

- 前端 js请求 -> 后端web服务器 
- 后端服务器 -> 分析服务器 
- 分析服务器 -> 请求ai服务器
- ai服务器提供算法和向量数据库

以上交互均通过http请求实现

### 视频流逻辑

- 摄像头rtmp推流到流媒体服务器
   > 流媒体对于流的标识符是<app>/<streamname>, 
   > 将原始流推到live/camera<n>中
   > 将处理后的流推到processec/camera<n>中

**向量服务器还是放在分析服务器**

## 进度

### 阶段一 图像检测 （🕐）

#### 1. 后端
5000端口

```python
    #请求/stat.json可获得
    #return live url  processed url
    get_camera_list(data)  ["GET"]
    analyzer_newdata() ["POST"]
```


#### 2. 分析服务器

9000端口

一直运行的基本功能：拉流，画框，推流
当检测到新的数据后向后端发送 [id，time]
同时将id图片存储到文件夹内

#### 3. ai服务器

```python
    #请求ai服务器 code: 使用的算法编码 1：人脸 2：人体 4：人脸人体 
    # return {"face": [{id, x1,y1,x2,y2, embedding}, ...] ,"body":[id, x1, x2, y1, y2], ...,embedding}
    algorithm_detect_frame(code, frame) ["POST"]
    #

```


### 阶段二 人脸识别（历史人脸查询与实时人脸检测）

#### 1. 前端 

人脸库管理页面
   人脸库显示目前的


#### 2. 后端api

```python
    analyzer_face_detect(id, time)
    face_search_by_id(id)
    face_search_by_image(id)

```


#### 2. 分析服务器

```python
    # return image
    face_image(id)
    # return all image
    # {[id,image],[id,image]}
    face_image_all()
    # 在处理视频帧时将检测的id人员高亮处理
    face_detect_by_id(id)
    face_detect_by_image(image)
    # 返回
    face_search_by_image()
```


#### 3. ai服务器



### 阶段三 预警大模型


```mermaid

graph LR
    A[多品牌IP摄像头] --> B(流媒体服务器);
    B --> C[Web管理平台 (Flask框架)];
    C --> D[云数据库];
    E[GPU服务器 (算法服务)] -- API调用 --> C;
    E --> D;
    C -- 设备配置, 任务调度, 数据可视化 --> F[用户界面];
    B -- 实时视频流 --> G[前端应用];
    G -- 用户交互 --> C;
    D -- 历史数据检索 --> C;
    
    style B fill:#lightblue,stroke:#333,stroke-width:2px;
    style C fill:#lightblue,stroke:#333,stroke-width:2px;
    style D fill:#lightblue,stroke:#333,stroke-width:2px;
    style E fill:#lightblue,stroke:#333,stroke-width:2px;
    style F fill:#lightblue,stroke:#333,stroke-width:2px;
    style G fill:#lightblue,stroke:#333,stroke-width:2px;
    
    subgraph "分层架构设计"
        B;
        C;
        D;
        E;
        F;
        G;
    end
```